import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _extends from '@babel/runtime/helpers/extends';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { CheckBox } from '@ui5/webcomponents-react/dist/CheckBox';
import { TableSelectionMode } from '@ui5/webcomponents-react/dist/TableSelectionMode';
import React, { useEffect } from 'react';
import { TableSelectionBehavior } from '@ui5/webcomponents-react/dist/TableSelectionBehavior';

var reOpenBracket = /\[/g;
var reCloseBracket = /\]/g;

function makePathArray(obj) {
  return flattenDeep(obj) // remove all periods in parts
  .map(function (d) {
    return String(d).replace('.', '_');
  }) // join parts using period
  .join('.') // replace brackets with periods
  .replace(reOpenBracket, '.').replace(reCloseBracket, '') // split it back out on periods
  .split('.');
}

function flattenDeep(arr) {
  var newArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!Array.isArray(arr)) {
    newArr.push(arr);
  } else {
    for (var i = 0; i < arr.length; i += 1) {
      flattenDeep(arr[i], newArr);
    }
  }

  return newArr;
} // copied from https://github.com/tannerlinsley/react-table/blob/master/src/utils.js#L169-L191 (13.Jan 2021)


var pathObjCache = new Map();
function getBy(obj, path, def) {
  if (!path) {
    return obj;
  }

  var cacheKey = typeof path === 'function' ? path : JSON.stringify(path);

  var pathObj = pathObjCache.get(cacheKey) || function () {
    var pathObj = makePathArray(path);
    pathObjCache.set(cacheKey, pathObj);
    return pathObj;
  }();

  var val;

  try {
    val = pathObj.reduce(function (cursor, pathPart) {
      return cursor[pathPart];
    }, obj);
  } catch (e) {// continue regardless of error
  }

  return typeof val !== 'undefined' ? val : def;
}

var customCheckBoxStyling = {
  verticalAlign: 'middle'
};

var headerProps = function headerProps(props, _ref) {
  var selectionMode = _ref.instance.webComponentsReactProperties.selectionMode;

  if (props.key === 'header___ui5wcr__internal_selection_column' && selectionMode === TableSelectionMode.MultiSelect) {
    return [props, {
      onClick: undefined,
      onKeyDown: undefined
    }];
  }

  return props;
};

var columns = function columns(_columns) {
  return _columns.map(function (column) {
    if (column.id === '__ui5wcr__internal_selection_column') {
      return _objectSpread(_objectSpread({}, column), {}, {
        Cell: function Cell(instance) {
          var webComponentsReactProperties = instance.webComponentsReactProperties,
              row = instance.row;

          if (row.disableSelect === true) {
            if (row.isGrouped && webComponentsReactProperties.selectionMode === TableSelectionMode.SingleSelect) {
              return null;
            }

            if (webComponentsReactProperties.selectionMode === TableSelectionMode.SingleSelect) {
              return /*#__PURE__*/React.createElement("div", {
                onClick: undefined,
                "data-name": "internal_selection_column"
              });
            }

            return /*#__PURE__*/React.createElement(CheckBox, _extends({}, row.getToggleRowSelectedProps(), {
              disabled: true,
              style: customCheckBoxStyling,
              "data-name": "internal_selection_column",
              tabIndex: -1
            }));
          }

          return column.Cell(instance);
        },
        Header: function Header() {
          return null;
        }
      });
    }

    return column;
  });
};
/**
 * A plugin hook for disabling row selection of specific rows.
 * __Note:__ The "Select All" checkbox is not available with this hook.
 *
 * @param disableRowSelection - Can be either a `string` or a `function`. `string:` Defines the key in the dataset for disabling rows. If the value of the key is `true`, then the row will not be selectable. `function:` Programmatically disable rows for selection. The function receives the current row as parameter.
 */


var useRowDisableSelection = function useRowDisableSelection(disableRowSelection) {
  var disableRowAccessor = typeof disableRowSelection === 'function' ? disableRowSelection : function (d) {
    return getBy(d.original, disableRowSelection, undefined);
  };

  var getRowProps = function getRowProps(rowProps, _ref2) {
    var row = _ref2.row,
        instance = _ref2.instance;
    var webComponentsReactProperties = instance.webComponentsReactProperties;

    if (disableRowAccessor(row) === true) {
      row.disableSelect = true;
      return _objectSpread(_objectSpread({}, rowProps), {}, {
        onClick: undefined,
        className: webComponentsReactProperties.classes.tr
      });
    }

    return rowProps;
  };

  var columnDeps = function columnDeps(deps) {
    return [].concat(_toConsumableArray(deps), [disableRowSelection]);
  };

  var useDisableSelectionRow = function useDisableSelectionRow(hooks) {
    hooks.getHeaderProps.push(headerProps);
    hooks.getRowProps.push(getRowProps);
    hooks.columns.push(columns);
    hooks.columnsDeps.push(columnDeps);
  };

  useDisableSelectionRow.pluginName = 'useRowDisableSelection';
  return useDisableSelectionRow;
};

var getParentIndicesRecursive = function getParentIndicesRecursive(rowId) {
  var parentIndices = {};

  var getParentIndices = function getParentIndices(internalRowId) {
    var lastDotIndex = internalRowId.lastIndexOf('.');

    if (~lastDotIndex) {
      var parentRowId = internalRowId.slice(0, lastDotIndex);

      if (!parentIndices[parentRowId]) {
        parentIndices[parentRowId] = true;
        getParentIndices(parentRowId);
      }
    }
  };

  getParentIndices(rowId);
  return parentIndices;
};
/**
 * A plugin hook that marks parent rows as indeterminate if a child row is selected in `MultiSelect` mode.
 * When using this hook, it is recommended to also select all sub-rows when selecting a row. (`reactTableOptions={{ selectSubRows: true }}`)
 */


var useIndeterminateRowSelection = function useIndeterminateRowSelection() {
  var toggleRowProps = function toggleRowProps(rowProps, _ref) {
    var row = _ref.row,
        instance = _ref.instance;
    var indeterminate;

    if (instance.isAllRowsSelected) {
      indeterminate = false;
    } else {
      var _instance$state$indet, _instance$state, _instance$state$indet2;

      indeterminate = (_instance$state$indet = instance === null || instance === void 0 ? void 0 : (_instance$state = instance.state) === null || _instance$state === void 0 ? void 0 : (_instance$state$indet2 = _instance$state.indeterminateRows) === null || _instance$state$indet2 === void 0 ? void 0 : _instance$state$indet2[row.id]) !== null && _instance$state$indet !== void 0 ? _instance$state$indet : false;
    }

    return [rowProps, {
      indeterminate: indeterminate,
      checked: indeterminate ? true : rowProps.checked
    }];
  };

  var stateReducer = function stateReducer(newState, action, prevState, instance) {
    if (action.type === 'INDETERMINATE_ROW_IDS') {
      var _instance$flatRows;

      var indeterminateRows = {};
      var allSelectedRows = {};
      var allSelected = true;
      var currentDepth = -1;
      (_instance$flatRows = instance.flatRows) === null || _instance$flatRows === void 0 ? void 0 : _instance$flatRows.filter(function (item) {
        return !item.original.emptyRow;
      }).sort(function (a, b) {
        return b.id.localeCompare(a.id);
      }).map(function (item) {
        if (currentDepth === -1) {
          currentDepth = item.depth;
        } else if (currentDepth !== item.depth) {
          currentDepth = item.depth;

          if (allSelected && newState.selectedRowIds[item.id]) {
            allSelectedRows[item.id] = true;
            delete indeterminateRows[item.id];
          }

          allSelected = true;
        }

        if (newState.selectedRowIds[item.id]) {
          var parentRowId = item.id.slice(0, item.id.lastIndexOf('.'));

          if (parentRowId) {
            indeterminateRows = _objectSpread(_objectSpread({}, indeterminateRows), getParentIndicesRecursive(item.id));
          }
        } else {
          allSelected = false;
        }

        return item;
      });
      return _objectSpread(_objectSpread({}, newState), {}, {
        indeterminateRows: indeterminateRows
      });
    }
  };

  var useInstanceAfterData = function useInstanceAfterData(instance) {
    var data = instance.data,
        dispatch = instance.dispatch,
        selectedRowIds = instance.state.selectedRowIds,
        _instance$webComponen = instance.webComponentsReactProperties,
        selectionMode = _instance$webComponen.selectionMode,
        selectionBehavior = _instance$webComponen.selectionBehavior,
        isTreeTable = _instance$webComponen.isTreeTable;
    useEffect(function () {
      if (isTreeTable && selectionMode === TableSelectionMode.MultiSelect && selectionBehavior !== TableSelectionBehavior.RowOnly) {
        dispatch({
          type: 'INDETERMINATE_ROW_IDS'
        });
      }
    }, [data, selectedRowIds, isTreeTable, selectionMode, selectionBehavior]);
  };

  var useIndeterminate = function useIndeterminate(hooks) {
    hooks.getToggleRowSelectedProps.push(toggleRowProps);
    hooks.stateReducers.push(stateReducer);
    hooks.useInstanceAfterData.push(useInstanceAfterData);
  };

  useIndeterminate.pluginName = 'useIndeterminate';
  return useIndeterminate;
};

export { useIndeterminateRowSelection, useRowDisableSelection };
//# sourceMappingURL=AnalyticalTableHooks.js.map
