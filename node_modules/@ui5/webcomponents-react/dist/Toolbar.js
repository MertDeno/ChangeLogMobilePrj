import _extends from '@babel/runtime/helpers/extends';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import { createUseStyles } from 'react-jss';
import { useSyncRef, useI18nBundle, useIsomorphicLayoutEffect } from '@ui5/webcomponents-react-base/dist/hooks';
import { deprecationNotice, debounce, enrichEventWithDetails } from '@ui5/webcomponents-react-base/dist/Utils';
import { SHOW_MORE } from '@ui5/webcomponents-react/dist/assets/i18n/i18n-defaults';
import { ToolbarDesign } from '@ui5/webcomponents-react/dist/ToolbarDesign';
import { ToolbarStyle } from '@ui5/webcomponents-react/dist/ToolbarStyle';
import React, { useEffect, useRef, useState, useCallback, forwardRef, useMemo, cloneElement, createRef } from 'react';
import '@ui5/webcomponents-icons/dist/overflow.js';
import { ButtonDesign } from '@ui5/webcomponents-react/dist/ButtonDesign';
import { PopoverPlacementType } from '@ui5/webcomponents-react/dist/PopoverPlacementType';
import { Popover } from '@ui5/webcomponents-react/dist/Popover';
import { ToggleButton } from '@ui5/webcomponents-react/dist/ToggleButton';
import { createPortal } from 'react-dom';
import { CssSizeVariables } from '@ui5/webcomponents-react-base/dist/CssSizeVariables';
import { ThemingParameters } from '@ui5/webcomponents-react-base/dist/ThemingParameters';
import clsx from 'clsx';

var useDeprecationNoticeForTooltip = function useDeprecationNoticeForTooltip(component, tooltip) {
  useEffect(function () {
    if (tooltip) {
      deprecationNotice(component, '`tooltip` has been deprecated, please use the native `title` attribute instead.');
    }
  }, [tooltip]);
};

var stopPropagation = function stopPropagation(e) {
  var _e$stopImmediatePropa;

  e.stopPropagation();
  (_e$stopImmediatePropa = e.stopImmediatePropagation) === null || _e$stopImmediatePropa === void 0 ? void 0 : _e$stopImmediatePropa.call(e);
};

var OverflowPopover = function OverflowPopover(props) {
  var lastVisibleIndex = props.lastVisibleIndex,
      contentClass = props.contentClass,
      children = props.children,
      portalContainer = props.portalContainer,
      overflowContentRef = props.overflowContentRef,
      numberOfAlwaysVisibleItems = props.numberOfAlwaysVisibleItems,
      showMoreText = props.showMoreText;
  var popoverRef = useRef();

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      pressed = _useState2[0],
      setPressed = _useState2[1];

  var handleToggleButtonClick = useCallback(function (e) {
    e.stopPropagation();

    if (popoverRef.current) {
      if (!pressed) {
        popoverRef.current.showAt(e.target);
        setPressed(true);
      } else {
        popoverRef.current.close();
      }
    }
  }, [pressed]);
  useEffect(function () {
    return function () {
      if (popoverRef.current) {
        popoverRef.current.close();
      }
    };
  }, []);
  var handleClose = useCallback(function (e) {
    stopPropagation(e);
    setPressed(false);
  }, [setPressed]);
  var renderChildren = useCallback(function () {
    return React.Children.toArray((children === null || children === void 0 ? void 0 : children.type) === React.Fragment ? children.props.children : children).map(function (item, index) {
      if (index > lastVisibleIndex && index > numberOfAlwaysVisibleItems - 1) {
        if (item.type.displayName === 'ToolbarSeparator') {
          return /*#__PURE__*/React.cloneElement(item, {
            style: {
              height: '0.0625rem',
              margin: '0.375rem 0.1875rem',
              width: '100%'
            }
          });
        }

        return item;
      }

      return null;
    });
  }, [children, lastVisibleIndex]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ToggleButton, {
    design: ButtonDesign.Transparent,
    icon: "overflow",
    onClick: handleToggleButtonClick,
    pressed: pressed,
    accessibleName: showMoreText
  }), /*#__PURE__*/createPortal( /*#__PURE__*/React.createElement(Popover, {
    placementType: PopoverPlacementType.Bottom,
    ref: popoverRef,
    onAfterClose: handleClose,
    hideArrow: true
  }, /*#__PURE__*/React.createElement("div", {
    className: contentClass,
    ref: overflowContentRef
  }, renderChildren())), portalContainer));
};

var styles = {
  outerContainer: {
    boxSizing: 'border-box',
    width: '100%',
    maxWidth: '100%',
    height: CssSizeVariables.sapWcrToolbarHeight,
    position: 'relative',
    overflow: 'hidden',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderBottom: "solid 0.0625rem ".concat(ThemingParameters.sapGroup_TitleBorderColor)
  },
  hasOverflow: {
    '& $toolbar': {
      maxWidth: 'calc(100% - 44px)'
    }
  },
  clear: {
    borderBottom: 'none'
  },
  active: {
    cursor: 'pointer',
    '&:active': {
      backgroundColor: ThemingParameters.sapActiveColor
    },
    '&:hover': {
      backgroundColor: ThemingParameters.sapList_Hover_Background
    }
  },
  info: {
    // This color is most similar to darken(@sapUiBaseColor, 10)
    backgroundColor: ThemingParameters.sapList_HeaderBorderColor,
    '&$active': {
      backgroundColor: ThemingParameters.sapInfobar_Active_Background,
      '&:active': {
        backgroundColor: "".concat(ThemingParameters.sapInfobar_Active_Background)
      },
      '&:hover': {
        backgroundColor: ThemingParameters.sapInfobar_Hover_Background
      }
    }
  },
  solid: {
    backgroundColor: ThemingParameters.sapBackgroundColor
  },
  transparent: {
    backgroundColor: ThemingParameters.sapToolbar_Background
  },
  toolbar: {
    width: '100%',
    '& >:first-child:not(.spacer)': {
      margin: '0 0.25rem 0 0'
    },
    '& >:last-child:not(.spacer)': {
      margin: '0 0.5rem 0 0.25rem'
    },
    '& > *:not(first-child):not(last-child):not(.spacer)': {
      margin: '0 0.25rem'
    },
    display: 'flex',
    alignItems: 'center',
    maxWidth: '100%'
  },
  overflowButtonContainer: {
    marginRight: '0.5rem'
  },
  popoverContent: {
    maxWidth: '20rem',
    padding: CssSizeVariables.sapWcrToolbarPopoverContentPadding,
    display: 'flex',
    flexDirection: 'column',
    '& [ui5-button]': {
      marginBottom: '0.25rem'
    },
    '& [ui5-button]::part(button)': {
      justifyContent: 'flex-start'
    },
    '& :last-child': {
      marginBottom: 0
    }
  },
  childContainer: {
    display: 'flex'
  }
};

var _excluded = ["children", "toolbarStyle", "design", "active", "style", "tooltip", "className", "onClick", "slot", "as", "portalContainer", "numberOfAlwaysVisibleItems", "onOverflowChange"];
var useStyles = createUseStyles(styles, {
  name: 'Toolbar'
});
var OVERFLOW_BUTTON_WIDTH = 32 + 8;
/**
 * Horizontal container most commonly used to display buttons, labels, selects and various other input controls.
 *
 * The content of the `Toolbar` moves into the overflow area from right to left when the available space is not enough in the visible area of the container.
 * It can be accessed by the user through the overflow button that opens it in a popover.
 */

var Toolbar = /*#__PURE__*/forwardRef(function (props, ref) {
  var children = props.children,
      toolbarStyle = props.toolbarStyle,
      design = props.design,
      active = props.active,
      style = props.style,
      tooltip = props.tooltip,
      className = props.className,
      onClick = props.onClick,
      slot = props.slot,
      as = props.as,
      portalContainer = props.portalContainer,
      numberOfAlwaysVisibleItems = props.numberOfAlwaysVisibleItems,
      onOverflowChange = props.onOverflowChange,
      rest = _objectWithoutProperties(props, _excluded);

  useDeprecationNoticeForTooltip('Toolbar', props.tooltip);
  var classes = useStyles();

  var _useSyncRef = useSyncRef(ref),
      _useSyncRef2 = _slicedToArray(_useSyncRef, 2),
      componentRef = _useSyncRef2[0],
      outerContainer = _useSyncRef2[1];

  var controlMetaData = useRef([]);

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      lastVisibleIndex = _useState2[0],
      setLastVisibleIndex = _useState2[1];

  var contentRef = useRef(null);
  var overflowContentRef = useRef(null);
  var overflowBtnRef = useRef(null);

  var _useState3 = useState('0'),
      _useState4 = _slicedToArray(_useState3, 2),
      minWidth = _useState4[0],
      setMinWidth = _useState4[1];

  var i18nBundle = useI18nBundle('@ui5/webcomponents-react');
  var showMoreText = i18nBundle.getText(SHOW_MORE);
  var toolbarClasses = clsx(classes.outerContainer, toolbarStyle === ToolbarStyle.Clear && classes.clear, active && classes.active, design === ToolbarDesign.Solid && classes.solid, design === ToolbarDesign.Transparent && classes.transparent, design === ToolbarDesign.Info && classes.info, className);
  var childrenWithRef = useMemo(function () {
    controlMetaData.current = [];
    var refactoredChildren = React.Children.toArray(children).map(function (child, index) {
      if (child.type === React.Fragment) {
        return child.props.children.filter(Boolean).map(function (item, itemIndex) {
          return /*#__PURE__*/cloneElement(item, {
            key: ".".concat(index, ":").concat(itemIndex)
          });
        });
      }

      return child;
    });
    return refactoredChildren.flat().map(function (item, index) {
      var _item$type;

      var itemRef = /*#__PURE__*/createRef();
      controlMetaData.current.push({
        ref: itemRef
      }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

      if ((item === null || item === void 0 ? void 0 : (_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.displayName) === 'ToolbarSpacer') {
        return item;
      }

      return /*#__PURE__*/React.createElement("div", {
        ref: itemRef,
        key: index,
        className: classes.childContainer,
        "data-component-name": "ToolbarChildContainer"
      }, item);
    });
  }, [children, controlMetaData, classes.childContainer]);
  var overflowNeeded = (lastVisibleIndex || lastVisibleIndex === 0) && React.Children.count(childrenWithRef) !== lastVisibleIndex + 1 && numberOfAlwaysVisibleItems < React.Children.count(children);
  useEffect(function () {
    var lastElementResizeObserver;
    var lastElement = contentRef.current.children[numberOfAlwaysVisibleItems - 1];

    if (numberOfAlwaysVisibleItems && overflowNeeded && lastElement) {
      lastElementResizeObserver = new ResizeObserver(debounce(function () {
        setMinWidth("".concat(lastElement.getBoundingClientRect().right + OVERFLOW_BUTTON_WIDTH, "px"));
      }, 200));
      lastElementResizeObserver.observe(contentRef.current);
    }

    return function () {
      var _lastElementResizeObs;

      (_lastElementResizeObs = lastElementResizeObserver) === null || _lastElementResizeObs === void 0 ? void 0 : _lastElementResizeObs.disconnect();
    };
  }, [numberOfAlwaysVisibleItems, overflowNeeded]);
  var requestAnimationFrameRef = useRef();
  var calculateVisibleItems = useCallback(function () {
    requestAnimationFrameRef.current = requestAnimationFrame(function () {
      if (!outerContainer.current) return;
      var availableWidth = outerContainer.current.getBoundingClientRect().width;
      var consumedWidth = 0;
      var lastIndex = null;

      if (availableWidth - OVERFLOW_BUTTON_WIDTH <= 0) {
        lastIndex = -1;
      } else {
        controlMetaData.current.forEach(function (item, index) {
          var currentMeta = controlMetaData.current[index];

          if (currentMeta && currentMeta.ref && currentMeta.ref.current) {
            var nextWidth = currentMeta.ref.current.getBoundingClientRect().width;
            nextWidth += index === 0 || index === controlMetaData.current.length - 1 ? 4 : 8; // first & last element = padding: 4px

            if (index === controlMetaData.current.length - 1) {
              if (consumedWidth + nextWidth <= availableWidth - 8) {
                lastIndex = index;
              }
            } else {
              if (consumedWidth + nextWidth <= availableWidth - OVERFLOW_BUTTON_WIDTH) {
                lastIndex = index;
              }

              if (consumedWidth < availableWidth - OVERFLOW_BUTTON_WIDTH && consumedWidth + nextWidth >= availableWidth - OVERFLOW_BUTTON_WIDTH) {
                lastIndex = index - 1;
              }
            }

            consumedWidth += nextWidth;
          }
        });
      }

      setLastVisibleIndex(lastIndex);
    });
  }, [outerContainer.current, controlMetaData.current, setLastVisibleIndex, childrenWithRef, overflowNeeded]);
  var observer = useRef(new ResizeObserver(calculateVisibleItems));
  useEffect(function () {
    if (outerContainer.current) {
      observer.current.observe(outerContainer.current);
    }

    return function () {
      cancelAnimationFrame(requestAnimationFrameRef.current);
      observer.current.disconnect();
    };
  }, [outerContainer.current]);
  useIsomorphicLayoutEffect(function () {
    calculateVisibleItems();
  }, [calculateVisibleItems]);
  var handleToolbarClick = useCallback(function (e) {
    if (active && typeof onClick === 'function') {
      onClick(enrichEventWithDetails(e));
    }
  }, [onClick, active]);
  useEffect(function () {
    if (lastVisibleIndex !== null && typeof onOverflowChange === 'function') {
      var _contentRef$current, _overflowContentRef$c;

      var toolbarChildren = (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 ? void 0 : _contentRef$current.children;
      var toolbarElements = [];
      var overflowElements = (_overflowContentRef$c = overflowContentRef.current) === null || _overflowContentRef$c === void 0 ? void 0 : _overflowContentRef$c.children;

      if ((toolbarChildren === null || toolbarChildren === void 0 ? void 0 : toolbarChildren.length) > 0) {
        toolbarElements = Array.from(toolbarChildren).filter(function (item, index) {
          return index <= lastVisibleIndex;
        });
      }

      onOverflowChange({
        toolbarElements: toolbarElements,
        overflowElements: overflowElements,
        target: outerContainer.current
      });
    }
  }, [lastVisibleIndex]);
  var CustomTag = as;
  var styleWithMinWidth = minWidth !== '0' ? _objectSpread({
    minWidth: minWidth
  }, style) : style;
  return /*#__PURE__*/React.createElement(CustomTag, _extends({
    title: tooltip,
    style: styleWithMinWidth,
    className: clsx(toolbarClasses, overflowNeeded && classes.hasOverflow),
    ref: componentRef,
    slot: slot,
    onClick: handleToolbarClick
  }, rest), /*#__PURE__*/React.createElement("div", {
    className: classes.toolbar,
    "data-component-name": "ToolbarContent",
    ref: contentRef
  }, overflowNeeded && React.Children.map(childrenWithRef, function (item, index) {
    if (index >= lastVisibleIndex + 1 && index > numberOfAlwaysVisibleItems - 1) {
      return /*#__PURE__*/React.cloneElement(item, {
        style: {
          visibility: 'hidden'
        }
      });
    }

    return item;
  }), !overflowNeeded && childrenWithRef), overflowNeeded && /*#__PURE__*/React.createElement("div", {
    ref: overflowBtnRef,
    className: classes.overflowButtonContainer,
    title: showMoreText,
    "data-component-name": "ToolbarOverflowButtonContainer"
  }, /*#__PURE__*/React.createElement(OverflowPopover, {
    lastVisibleIndex: lastVisibleIndex,
    contentClass: classes.popoverContent,
    portalContainer: portalContainer,
    overflowContentRef: overflowContentRef,
    numberOfAlwaysVisibleItems: numberOfAlwaysVisibleItems,
    showMoreText: showMoreText
  }, React.Children.toArray(children).map(function (child) {
    if (child.type === React.Fragment) {
      return child.props.children;
    }

    return child;
  }))));
});
Toolbar.defaultProps = {
  as: 'div',
  toolbarStyle: ToolbarStyle.Standard,
  design: ToolbarDesign.Auto,
  active: false,
  portalContainer: document.body,
  numberOfAlwaysVisibleItems: 0
};
Toolbar.displayName = 'Toolbar';

export { Toolbar };
//# sourceMappingURL=Toolbar.js.map
