import { useRef, useEffect, useMemo, useState, useLayoutEffect } from 'react';
import { deprecationNotice } from '@ui5/webcomponents-react-base/dist/Utils';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { getI18nBundle } from '@ui5/webcomponents-base/dist/i18nBundle.js';
import formatMessage from '@ui5/webcomponents-base/dist/util/formatMessage.js';
import { attachLanguageChange, detachLanguageChange } from '@ui5/webcomponents-base/dist/locale/languageChange.js';
import { useIsomorphicLayoutEffect as useIsomorphicLayoutEffect$1 } from '@ui5/webcomponents-react-base/dist/hooks';
import { getRTL } from '@ui5/webcomponents-base/dist/config/RTL.js';
import { getCurrentRange, attachMediaHandler, detachMediaHandler } from '@ui5/webcomponents-react-base/dist/Device';
import { createUseStyles } from 'react-jss';

var useConsolidatedRef = function useConsolidatedRef(ref) {
  var localRef = useRef(null);
  useEffect(function () {
    deprecationNotice('useConsolidatedRef', "`useConsolidatedRef` is deprecated. Please use `useSyncRef` instead.");
  }, []);
  var consolidatedRef = useMemo(function () {
    if (!ref || typeof ref === 'function') {
      return localRef;
    }

    return ref;
  }, [ref]);
  useEffect(function () {
    if (typeof ref === 'function') {
      ref(consolidatedRef.current);
    }
  }, [consolidatedRef.current]);
  return consolidatedRef;
};

var defaultBundle = {
  getText: function getText(val) {
    var _ref, _val$defaultText;

    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    return formatMessage((_ref = (_val$defaultText = val === null || val === void 0 ? void 0 : val.defaultText) !== null && _val$defaultText !== void 0 ? _val$defaultText : val) !== null && _ref !== void 0 ? _ref : '', values);
  }
};
var i18nBundles = new Map([]);
var useI18nBundle = function useI18nBundle(bundleName) {
  var _i18nBundles$get;

  var _useState = useState((_i18nBundles$get = i18nBundles.get(bundleName)) !== null && _i18nBundles$get !== void 0 ? _i18nBundles$get : defaultBundle),
      _useState2 = _slicedToArray(_useState, 2),
      bundle = _useState2[0],
      setBundle = _useState2[1];

  var _useState3 = useState(0),
      _useState4 = _slicedToArray(_useState3, 2);
      _useState4[0];
      var setUpdater = _useState4[1];

  useIsomorphicLayoutEffect$1(function () {
    var isMounted = true;

    var fetchI18n = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(newLanguage) {
        var internalBundle;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return getI18nBundle(bundleName);

              case 2:
                internalBundle = _context.sent;

                if (isMounted) {
                  if (!i18nBundles.has(bundleName) || newLanguage) {
                    setBundle(internalBundle);
                    setUpdater(function (prev) {
                      return prev + 1;
                    });
                  }

                  i18nBundles.set(bundleName, internalBundle);
                }

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function fetchI18n(_x) {
        return _ref2.apply(this, arguments);
      };
    }();

    fetchI18n();
    attachLanguageChange(fetchI18n);
    return function () {
      detachLanguageChange(fetchI18n);
      isMounted = false;
    };
  }, [bundleName]);
  return bundle;
};

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;

var GLOBAL_DIR_CSS_VAR = '--_ui5_dir';

var detectRTL = function detectRTL(elementRef) {
  var _elementRef$current;

  if (!elementRef.current) {
    return getRTL();
  }

  var doc = window.document;
  var dirValues = ['ltr', 'rtl']; // exclude "auto" and "" from all calculations

  var locallyAppliedDir = getComputedStyle(elementRef.current).getPropertyValue(GLOBAL_DIR_CSS_VAR); // In that order, inspect the CSS Var (for modern browsers), the element itself, html and body (for IE fallback)

  if (dirValues.includes(locallyAppliedDir)) {
    return locallyAppliedDir === 'rtl';
  }

  if (dirValues.includes((_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.dir)) {
    var _elementRef$current2;

    return ((_elementRef$current2 = elementRef.current) === null || _elementRef$current2 === void 0 ? void 0 : _elementRef$current2.dir) === 'rtl';
  }

  if (dirValues.includes(doc.documentElement.dir)) {
    return doc.documentElement.dir === 'rtl';
  }

  if (dirValues.includes(doc.body.dir)) {
    return doc.body.dir === 'rtl';
  } // Finally, check the configuration for explicitly set RTL or language-implied RTL


  return getRTL();
};

var useIsRTL = function useIsRTL(elementRef) {
  var _useState = useState(getRTL()),
      _useState2 = _slicedToArray(_useState, 2),
      isRTL = _useState2[0],
      setRTL = _useState2[1]; // use config RTL as best guess


  var isMounted = useRef(false);
  useIsomorphicLayoutEffect$1(function () {
    isMounted.current = true;
    setRTL(detectRTL(elementRef)); // update immediately while rendering

    var targets = [document.documentElement, document.body, elementRef.current].filter(Boolean);
    var observer = new MutationObserver(function (mutations) {
      mutations.forEach(function (mutation) {
        if (mutation.attributeName === 'dir') {
          if (isMounted.current) {
            setRTL(detectRTL(elementRef));
          }
        }
      });
    });
    targets.forEach(function (target) {
      observer.observe(target, {
        attributes: true,
        childList: false,
        characterData: false,
        attributeFilter: ['dir']
      });
    });
    return function () {
      isMounted.current = false;
      observer.disconnect();
    };
  }, [isMounted]);
  return isRTL;
};

var PROP_INCLUDELIST = /^(aria-|data-|id$|on[A-Z]|slot$|role$)/;
/**
 * @deprecated please use rest/spread syntax instead. `{ propA, propB, ...rest } = props`
 */

var usePassThroughHtmlProps = function usePassThroughHtmlProps(props) {
  var propExcludeList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var componentPropExcludelist = new Set(propExcludeList);
  useEffect(function () {
    deprecationNotice('usePassThroughHtmlProps', "`usePassThroughHtmlProps` is deprecated. Please use rest/spread syntax instead. `{ propA, propB, ...rest } = props`");
  }, []);
  var returnVal = {};

  for (var name in props) {
    if (PROP_INCLUDELIST.test(name) && !componentPropExcludelist.has(name)) {
      returnVal[name] = props[name];
    }
  }

  return returnVal;
};

var useStyles = createUseStyles({
  Phone: {
    paddingLeft: '1rem',
    paddingRight: '1rem'
  },
  Tablet: {
    paddingLeft: '2rem',
    paddingRight: '2rem'
  },
  Desktop: {
    paddingLeft: '2rem',
    paddingRight: '2rem'
  },
  LargeDesktop: {
    paddingLeft: '3rem',
    paddingRight: '3rem'
  }
}, {
  name: 'StdExtPadding'
});
/**
 * Hook for creating a style class, which sets `padding-left` and `padding-right` depending on the width of the element.
 *
 * @param {HTMLElement} element
 */

var useResponsiveContentPadding = function useResponsiveContentPadding(element) {
  var _useState = useState(getCurrentRange().name),
      _useState2 = _slicedToArray(_useState, 2),
      currentRange = _useState2[0],
      setCurrentRange = _useState2[1];

  var classes = useStyles();
  var requestAnimationFrameRef = useRef();
  useEffect(function () {
    var observer = new ResizeObserver(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          el = _ref2[0];

      cancelAnimationFrame(requestAnimationFrameRef.current);
      requestAnimationFrameRef.current = requestAnimationFrame(function () {
        setCurrentRange(function () {
          var _getCurrentRange;

          return (_getCurrentRange = getCurrentRange(el.contentRect.width)) === null || _getCurrentRange === void 0 ? void 0 : _getCurrentRange.name;
        });
      });
    });

    if (element) {
      observer.observe(element);
    }

    return function () {
      observer.disconnect();
      cancelAnimationFrame(requestAnimationFrameRef.current);
    };
  }, [element]);
  return classes[currentRange];
};

var useViewportRange = function useViewportRange() {
  var _useState = useState(getCurrentRange().name),
      _useState2 = _slicedToArray(_useState, 2),
      currentRange = _useState2[0],
      setCurrentRange = _useState2[1];

  useEffect(function () {
    var isMounted = true;

    var handler = function handler(_ref) {
      var range = _ref.name;

      if (isMounted === true) {
        setCurrentRange(range);
      }
    };

    attachMediaHandler(handler);
    return function () {
      isMounted = false;
      detachMediaHandler(handler);
    };
  }, [setCurrentRange]);
  return currentRange;
};

function useSyncRef(ref) {
  var localRef = useRef(null);

  var componentRef = function componentRef(node) {
    if (ref) {
      if (typeof ref === 'function') {
        ref(node);
      }

      if ({}.hasOwnProperty.call(ref, 'current')) {
        ref.current = node;
      }
    }

    localRef.current = node;
  };

  return [componentRef, localRef];
}

export { useConsolidatedRef, useI18nBundle, useIsRTL, useIsomorphicLayoutEffect, usePassThroughHtmlProps, useResponsiveContentPadding, useSyncRef, useViewportRange };
//# sourceMappingURL=hooks.js.map
